
% LATITUDE AND LONGITUDE - GROUNDTRACK
% -------------------------------------------------------------------------------------------------
% Generates Latitude and Longitude coordinates for a satellite in orbit over Earth Reference 
% Ellipsoid from input Position and Velocity vector in a Geocentric-Equatorial frame (GCRF), and 
% the corresponding Date/Time (UTC). The determined orbit and resulting data defined by 2-body 
% motion. Data is generated for a specified number of revolutions (numorb) past the input state. 
% Circular or elliptical orbits only.
%
% Data generated by this function can be plotted to create groundtrack of satellite.
% Output LATITUDE and LONGITUDE matrices each contain 1 column for each revolution.
%
% Author: Matthew Buckhout
% Updated: 08/24/2020 
%
% Inputs:
%
%     - [R]             Position Vector at Date/Time (GCRF)             [km]
%     - [V]             Velocity Vector at Date/Time (GCRF)             [km/s]
%     - [DATE]          Gregorian Date                                  [yyyy mm dd]
%     - [TIME]          Coordinated Universal Time (UTC)                [hh mm ss]
%     - [dUT1]          UT1 - UTC                                       [sec]
%     - [dAT]           TAI - UTC                                       [sec]
%     - [numorb]        Number of revolutions to generate                -
%                          groundtrack data for
%
% Outputs:
%
%     - [LATITUDE]      Matrix of latitude coordinates                  [deg]
%     - [LONGITUDE]     Matrix of longitude coordinates                 [deg]
%
% Functions:
%
%     - convert_time
%     - julian_date
%     - orbital_elements
%     - eccentric_anomaly
%     - mean_anomaly
%     - position_velocity
%     - local_sidereal
%     - ECI_ground
%
% References:
%     - Fundamentals of Astrodynamics with Applications, 2nd ed. (Vallado) (pg. 179-197, 189-192) 
% -------------------------------------------------------------------------------------------------

function [LATITUDE,LONGITUDE] = groundtrack(R,V,DATE,TIME,dUT1,dAT,numorb)
   
   %Constants
   RE = 6378.1363; %[km] Earth Mean Equatorial Radius 
   mu = 3.986004415e5; %[km^3/s^2] Earth Gravitational Parameter
   
   [UT1,~,~,~,~,~,~] = convert_time(DATE,TIME,dUT1,dAT); %Universal Time   
  
   [~,MJD0] = julian_date(DATE,UT1,0); %Modified Julian Date (UT1)
   
   [p,a,e,i,OMEGA,omega,theta0,omega_true,lambda_true,u] = orbital_elements(mu,R,V); %Orbital Elements

   [EBH0] = eccentric_anomaly(e,theta0); %Eccentric Anomaly

   [M0] = mean_anomaly(e,EBH0); %Initial Mean Anomaly

   %Looping Number of Orbits
   knum = numorb;
   for k=1:1:knum

      %Updating Time of Orbit Start
      if (k > 1)
         T = 2*pi*sqrt((a^3)/mu); %[sec] Orbital Period 
         MJD0 = MJD0 + T/86400; %[days] Start MJD for orbit k (UT1) 
      end
      
      %Looping True Anomaly
      fine = 300; %Number of points per revolution
      jnum = fine;
      for j=1:1:jnum
         
         %Iterated True Anomaly
         theta = theta0 + ((j*(2*pi/fine)) - (2*pi/fine));
         if (theta > (2*pi))
            theta = theta - (2*pi);
         end

         [EBH] = eccentric_anomaly(e,theta); %Eccentric Anomaly

         [M] = mean_anomaly(e,EBH); %Final Mean Anomaly

         %Computing Change in Time 
         if (e < 1)
            n = sqrt(mu/(a^3));
            dt = (M - M0)/n;
            if (dt < 0) %Accounting for M crossing Periapsis
               dt = ((2*pi) + M - M0)/n;
            end
         elseif (e > 1)
            nh = sqrt(mu/(-(a^3)));
            dt = (M - M0)/nh;
         elseif (e == 1)
            np = 2*sqrt(mu/(p^3));
            dt = (M - M0)/np; 
         end
         
         MJD = MJD0 + dt/86400; %[days] Updated MJD for time step along orbit k (UT1)
         
         [R_GCRF,V_GCRF] = position_velocity(mu,p,e,i,OMEGA,omega,theta,omega_true,lambda_true,u); %Position and Velocity Vector 
         
         [~,GMST] = local_sidereal(0,MJD); %[rad] %Greenwich Mean Standard Time     
         
         [Lat,Long,~] = ECI_ground(R_GCRF,GMST); %[deg] %Sub-Latitude Point

         LATITUDE(j,k) = Lat; %[deg] Output matrix, Latitudes for each orbit
         LONGITUDE(j,k) = Long; %[deg] Output matrix, Longitudes for each orbit
         
      end

   end
   
end
